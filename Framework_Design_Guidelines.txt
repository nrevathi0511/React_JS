# Framework Design Guidelines

## 1. Naming Guidelines

-  1.1 Capitalization Conventions
  -  Do
    -  Capitalization Rules for Identifiers
      -  PascalCasing
        -  All public member, type, and namespace names consisting of multiple words
          -  Namespace
          -  Type
          -  Interface
          -  Method
          -  Property
          -  Event
          -  Field
          -  Enum value
      - camelCasing
        - Parameter names
  -  Do Not
    -  DO NOT capitalize each word in so-called closed-form compound words
      -  callback
      -  email
      -  endpoint
      -  gridline
      -  hashtable
      -  id
      -  metadata
      -  multipanel
      -  multiview
      -  namespace
      -  ok
      -  pi
      -  placeholder
      -  writable
    -  DO NOT assume that all programming languages are case sensitive
-  1.2 General Naming Conventions
  -  Do
    -  DO choose easily readable identifier names
    -  DO favor readability over brevity
  -  Avoid
    -  AVOID using identifiers that conflict with keywords of widely used programming languages
  -  Do Not
    -  DO NOT use underscores, hyphens, or any other nonalphanumeric characters
    -  DO NOT use Hungarian notation
-  1.3 Names of Assemblies and DLLs
  -  Do
    -  DO choose names for your assembly DLLs that suggest large chunks of functionality, such as System.Data
  -  Consider

     CONSIDER naming DLLs according to the following pattern:                              <Company>.<Component>.dll
-  1.4 Names of Namespaces
  -  Do
    -  General Rule: 
    -  DO prefix namespace names with a company name to prevent namespaces from different companies from having the same name
    -  DO use a stable, version-independent product name at the second level of a namespace name
    -  DO use PascalCasing, and separate namespace components with periods (e.g., Microsoft.Office.PowerPoint)
  -  Consider
    -  CONSIDER using plural namespace names where appropriate
  -  Do Not
    -  DO NOT use organizational hierarchies as the basis for names in namespace hierarchies
    -  DO NOT use the same name for a namespace and a type in that namespace
  -  Namespaces and Type Name Conflicts
    -  DO NOT introduce generic type names such as Element, Node, Log, and Message, instead use FormElement, XmlNode, EventLog, SoapMessage
    -  DO NOT give the same name to types in namespaces within a single application model e.g., Page to the System.Web.UI.Adapters, as System.Web.UI.Page is already there.
    -  DO NOT give types names that would conflict with any type in the Core namespaces e.g., Stream as a type name. It would conflict with System.IO.Stream
    -  DO NOT assign type names that would conflict with other types within a single technology
    -  DO NOT introduce type name conflicts between types in technology namespaces and an application model namespace
-  1.5 Names of Classes, Structs, and Interfaces
  -  Do
    -  DO name classes and structs with nouns or noun phrases, using PascalCasing
    -  DO name interfaces with adjective phrases, or occasionally with nouns or noun phrases
    -  DO prefix interface names with the letter I, to indicate that the type is an interface e.g., IComponent (descriptive noun), ICustomAttributeProvider (noun phrase), and IPersistable (adjective)
    -  DO ensure that the names differ only by the "I" prefix on the interface name when you are defining a class–interface pair where the class is a standard implementation of the interface
  -  Consider
    -  CONSIDER ending the name of derived classes with the name of the base class
  -  Do Not
    -  DO NOT give class names a prefix (e.g., "C")

  ## 1.5.1 Names of Generic Type Parameters

  - DO name generic type parameters with descriptive names unless a single-letter name is completely self-explanatory and a descriptive name would not add value
  - CONSIDER using T as the type parameter name for types with one single-letter type parameter e.g.,IComparer<T>, Predicate<T>, Nullable<T>
  - DO prefix descriptive type parameter names with T. e.g., ISessionChannel<TSession>
  - CONSIDER indicating constraints placed on a type parameter in the name of the parameter e.g., public interface ISessionChannel<TSession> where TSession : ISession { TSession Session { get; } }

  ## 1.5.2 Names of Common Types

  - DO follow the guidelines described in the following list when naming types derived from or implementing certain .NET Framework types.
    -  System.Attribute
      -  DO add the suffix "Attribute" to names of custom attribute classes
    -  System.Delegate
      -  DO add the suffix "EventHandler" to names of delegates that are used in events
      -  DO add the suffix "Callback" to names of delegates other than those used as event handlers.
      -  DO NOT add the suffix "Delegate" to a delegate
    -  System.EventArgs
      -  DO add the suffix "EventArgs."
    -  System.Enum
      -  DO NOT derive from this class; use the keyword supported by your language instead; for example, in C#, use the enum keyword.
      -  DO NOT add the suffix "Enum" or "Flag."
    -  System.Exception
      -  DO add the suffix "Exception."
    -  IDictionary, IDictionary<TKey,TValue>
      -  DO add the suffix "Dictionary." Note that IDictionary is a specific type of collection, but this guideline takes precedence over the more general collections guideline that follows.
    -  IEnumerable, ICollection, IListIEnumerable<T>, ICollection<T>, IList<T>
      -  DO add the suffix "Collection."
    -  System.IO.Stream
      -  DO add the suffix "Stream."
    -  CodeAccessPermission, IPermission
      -  DO add the suffix "Permission."

  ## 1.5.3 Naming Enumerations

  - DO use a singular type name for an enumeration unless its values are bit fields
  - DO use a plural type name for an enumeration with bit fields as values, also called flags enum
  - DO NOT use an "Enum" suffix in enum type names.
  - DO NOT use "Flag" or "Flags" suffixes in enum type names.
  - DO NOT use a prefix on enumeration value names (e.g., "ad" for ADO enums, "rtf" for rich text enums, etc.).

-  1.6 Names of Type Members

  ## 1.6.1 Names of Methods

  - DO give methods names that are verbs or verb phrases.

  ## 1.6.2 Names of Properties 

  - DO name properties using a noun, noun phrase, or adjective
  - DO name collection properties with a plural phrase describing the items in the collection instead of using a singular phrase followed by "List" or "Collection"
  - DO name Boolean properties with an affirmative phrase (CanSeek instead of CantSeek). Optionally, you can also prefix Boolean properties with "Is", "Can", or "Has", but only where it adds value.
  - CONSIDER giving a property the same name as its type.
  - DO NOT have properties that match the name of "Get" methods

  ## 1.6.3 Names of Events

  - DO name events with a verb or a verb phrase.
  - DO give events names with a concept of before and after, using the present and past tenses

  - DO name event handlers (delegates used as types of events) with the "EventHandler" suffix, as shown in the following example: public delegate void ClickedEventHandler(object sender, ClickedEventArgs e);

  - DO use two parameters named sender and e in event handlers.

  - DO name event argument classes with the "EventArgs" suffix

  - DO NOT use "Before" or "After" prefixes or postfixes to indicate pre- and post-events

  ## 1.6.4 Names of Fields

  - DO use PascalCasing in field names
  - DO name fields using a noun, noun phrase, or adjective
  - DO NOT use a prefix for field names

-  1.7 Naming Parameters
  -   DO use camelCasing in parameter names
  -   DO use descriptive parameter names
  -   CONSIDER using names based on a parameter’s meaning rather than the parameter’s type
  -  Naming Operator Overload Parameters
    -  DO use left and right for binary operator overload parameter names if there is no meaning to the parameters.
    -  DO use value for unary operator overload parameter names if there is no meaning to the parameters
    -  CONSIDER meaningful names for operator overload parameters if doing so adds significant value
    -  DO NOT use abbreviations or numeric indices for operator overload parameter names
-  1.8 Naming Resources
  -  DO use PascalCasing in resource keys
  -  DO provide descriptive rather than short identifiers
  -  DO use only alphanumeric characters and underscores in naming resources

  DO use the following naming convention for exception message resources. The resource identifier should be the exception type name plus a short identifier of the exception:  ArgumentExceptionIllegalCharacters,  ArgumentExceptionInvalidName, ArgumentExceptionFileNameIsMalformed

  DO NOT use language-specific keywords of the main CLR languages

## 2. Type Design Guidelines

-  DO ensure that each type is a well-defined set of related members, not just a random collection of unrelated functionality
-  2.1 Choosing Between Class and Struct
  -  CONSIDER defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects
  -  AVOID defining a struct unless the type has all of the following characteristics
    -  It logically represents a single value, similar to primitive types ( int , double , etc.).
    -  It has an instance size under 16 bytes.
    -  It is immutable
    -  It will not have to be boxed frequently
-  2.2 Abstract Class Design
  -  DO define a protected or an internal constructor in abstract classes.
  -  DO provide at least one concrete type that inherits from each abstract class that you ship
  -  DO NOT define public or protected internal constructors in abstract types
-  2.3 Static Class Design
  -  DO use static classes sparingly
  -  DO declare static classes as sealed, abstract, and add a private instance constructor
  -  DO NOT treat static classes as a miscellaneous bucket
  -  DO NOT declare or override instance members in static classes
-  2.4 Interface Design
  -  DO define an interface if you need some common API to be supported by a set of types that includes value types
  -  DO provide at least one type that is an implementation of an interface
  -  DO provide at least one API that consumes each interface you define
  -  CONSIDER defining an interface if you need to support its functionality on types that already inherit from some other type
  -  AVOID using marker interfaces (with no members)
  -  DO NOT add members to an interface that has previously shipped
-  2.5 Struct Design
  -  DO ensure that a state where all instance data is set to zero, false, or null (as appropriate) is valid
  -  DO implement IEquatable on value types
  -  DO NOT provide a parameterless constructor for a struct
  -  DO NOT define mutable value types
  -  DO NOT explicitly extend ValueType.
-  2.6 Enum Design
  -  DO use an enum to strongly type parameters, properties, and return values that represent sets of values
  -  DO favor using an enum instead of static constants
  -  DO provide a value of zero on simple enums
-  2.7 Nested Types
  -  DO use nested types when the relationship between the nested type and its outer type is such that member-accessibility semantics are desirable
  -  AVOID publicly exposed nested types. The only exception to this is if variables of the nested type need to be declared only in rare scenarios such as subclassing or other advanced customization scenarios
  -  DO NOT use public nested types as a logical grouping construct; use namespaces for this
  -  DO NOT use nested types if the type is likely to be referenced outside of the containing type
  -  DO NOT use nested types if they need to be instantiated by client code. If a type has a public constructor, it should probably not be nested
  -  DO NOT define a nested type as a member of an interface

## 3. Member Design

-  Methods, properties, events, constructors, and fields -
  -  3.1 Member Overloading
    -  Do
      -  DO try to use descriptive parameter names to indicate the default used by shorter overloads
      -  DO make only the longest overload virtual (if extensibility is required)
      -  DO allow null to be passed for optional arguments
      -  DO use member overloading rather than defining members with default arguments
    -  Avoid
      -  AVOID arbitrarily varying parameter names in overloads
      -  AVOID being inconsistent in the ordering of parameters in overloaded members
    -  Do Not
      -  DO NOT use ref or out modifiers to overload members
      -  DO NOT have overloads with parameters at the same position and similar types yet with different semantics
  -  3.2 Property Design
    -  Do
      -  DO create get-only properties if the caller should not be able to change the value of the property
      -  DO provide sensible default values for all properties, ensuring that the defaults do not result in a security hole or terribly inefficient code
      -  DO allow properties to be set in any order even if this results in a temporary invalid state of the object
      -  DO preserve the previous value if a property setter throws an exception
    -  Avoid
      -  AVOID throwing exceptions from property getters
    -  Do Not
      -  DO NOT provide set-only properties or properties with the setter having broader accessibility than the getter. e.g., a public setter and a protected getter
    -  3.2.1 Indexed Property Design
      -  Do
        -  DO use the name Item for indexed properties unless there is an obviously better name
      -  Consider
        -  CONSIDER using indexers to provide access to data stored in an internal array
        -  CONSIDER providing indexers on types representing collections of items
      -  Avoid
        -  AVOID using indexed properties with more than one parameter
        -  AVOID indexers with parameter types other than System.Int32, System.Int64, System.String, System.Object, or an enum
      -  Do Not
        -  DO NOT provide both an indexer and methods that are semantically equivalent
        -   DO NOT provide more than one family of overloaded indexers in one type
        -  DO NOT use nondefault indexed properties
    -  3.2.2 Property Change Notification Events
      -  Consider
        -  CONSIDER raising change notification events when property values in high-level APIs (usually designer components) are modified.
        -  CONSIDER raising change notification events when the value of a property changes via external forces
  -  3.3 Constructor Design
    -  Do
      -  DO use constructor parameters as shortcuts for setting main properties
      -  DO use the same name for constructor parameters and a property if the constructor parameters are used to simply set the property
      -  DO minimal work in the constructor
      -  DO throw exceptions from instance constructors, if appropriate
      -  DO explicitly declare the public parameterless constructor in classes, if such a constructor is required
    -  Consider
      -  CONSIDER providing simple, ideally default, constructors
      -  CONSIDER using a static factory method instead of a constructor if the semantics of the desired operation do not map directly to the construction of a new instance, or if following the constructor design guidelines feels unnatural
    -  Avoid
      -  AVOID explicitly defining parameterless constructors on structs
      -  AVOID calling virtual members on an object inside its constructor
    -  Type Constructor Guidelines
      -  Do
        -  DO make static constructors private
      -  Do Not
        -  DO NOT throw exceptions from static constructors
      -  Consider
        -  CONSIDER initializing static fields inline rather than explicitly using static constructors, because the runtime is able to optimize the performance of types that don’t have an explicitly defined static constructor
  -  3.4 Event Design
    -  Do
      -  DO use the term "raise" for events rather than "fire" or "trigger."
      -  DO use System.EventHandler<TEventArgs> instead of manually creating new delegates to be used as event handlers
      -  DO use a protected virtual method to raise each event. This is only applicable to nonstatic events on unsealed classes, not to structs, sealed classes, or static events.
      -  DO take one parameter to the protected method that raises an event
      -  DO pass null as the sender when raising a static event
    -  Consider
      -  CONSIDER using a subclass of EventArgs as the event argument, unless you are absolutely sure the event will never need to carry any data to the event handling method
      -  CONSIDER raising events that the end user can cancel. This only applies to pre-events
    -  Do Not
      -  DO NOT pass null as the sender when raising a nonstatic event
      -  DO NOT pass null as the event data parameter when raising an event
    -  Custom Event Handler Design
      -  Do
        -  DO use a return type of void for event handlers
        -  DO use object as the type of the first parameter of the event handler, and call it 'sender' .
        -  DO use System.EventArgs or its subclass as the type of the second parameter of the event handler, and call it 'e'
      -  Do Not
        -  DO NOT have more than two parameters on event handlers
  -  3.5 Field Design
    -  Do
      -  DO use constant fields for constants that will never change
      -  DO use public static readonly fields for predefined object instances
    -  Do Not
      -  DO NOT provide instance fields that are public or protected
      -  DO NOT assign instances of mutable types to readonly fields
  -  3.6 Extension Methods
    -  Consider
      -  To provide helper functionality relevant to every implementation of an interface
      -  When an instance method would introduce a dependency on some type, but such a dependency would break dependency management rules
      -  CONSIDER defining extension methods in the same namespace as the extended type if the type is an interface and if the extension methods are meant to be used in most or all cases
    -  Avoid
      -  AVOID frivolously defining extension methods, especially on types you don't own.
      -  AVOID defining extension methods on System.Object
      -  AVOID defining two or more extension methods with the same signature, even if they reside in different namespaces.
      -  AVOID generic naming of namespaces dedicated to extension methods
    -  Do Not
      -  DO NOT put extension methods in the same namespace as the extended type
      -  DO NOT define extension methods implementing a feature in namespaces normally associated with other features
  -  3.7 Operator Overloads
    -  Do
      -  DO define operator overloads in structs that represent numbers
      -  DO overload operators in a symmetric fashion, == != < >
    -  Consider
      -  CONSIDER defining operator overloads in a type that should feel like a primitive type
      -  CONSIDER providing methods with friendly names that correspond to each overloaded operator
    -  Avoid
      -  AVOID defining operator overloads, except in types that should feel like primitive (built-in) types
    -  Do Not
      -  DO NOT be cute when defining operator overloads
      -  DO NOT provide operator overloads unless at least one of the operands is of the type defining the overload
    -  Conversion Operators
      -  Do
        -  DO throw System.InvalidCastException if a call to a cast operator results in a lossy conversion
      -  Do Not
        -  DO NOT provide a conversion operator if such conversion is not clearly expected by the end users
        -   DO NOT define conversion operators outside of a type’s domain
        -  DO NOT provide an implicit conversion operator if the conversion is potentially lossy
        -  DO NOT throw exceptions from implicit casts
  -  3.8 Parameter Design
    -  DO use the least derived parameter type that provides the functionality required by the member
    -  DO place all out parameters following all of the by-value and ref parameters
    -  DO be consistent in naming parameters when overriding members or implementing interface members
    -  DO NOT use reserved parameters
    -  DO NOT have publicly exposed methods that take pointers, arrays of pointers, or multidimensional arrays as parameters
    -  3.8.1 Choosing Between Enum and Boolean Parameters
      -  DO use enums if a member would otherwise have two or more Boolean parameters
      -  CONSIDER using Booleans for constructor parameters that are truly two-state values and are simply used to initialize Boolean properties
      -  DO NOT use Booleans unless you are absolutely sure there will never be a need for more than two values
    -  3.8.2 Validating Arguments
      -  DO validate arguments passed to public, protected, or explicitly implemented members
      -  DO throw ArgumentNullException if a null argument is passed and the member does not support null arguments
      -  DO validate enum parameters
      -  DO be aware that mutable arguments might have changed after they were validated
      -  DO NOT use Enum.IsDefined for enum range checks
    -  3.8.3 Parameter Passing
      -  AVOID using out or ref parameters
      -  DO NOT pass reference types by reference
    -  3.8.4 Members with Variable Number of Parameters
      -  DO try to order parameters to make it possible to use the params keyword
      -  DO be aware that null could be passed as a params array argument
      -  CONSIDER adding the params keyword to array parameters if you expect the end users to pass arrays with a small number of elements
      -  CONSIDER using the params keyword in a simple overload, even if a more complex overload could not use it
      -  CONSIDER providing special overloads and code paths for calls with a small number of arguments in extremely performance-sensitive APIs
      -  AVOID using params arrays if the caller would almost always have the input already in an array
      -  DO NOT use params arrays if the array is modified by the member taking the params array parameter
      -  DO NOT use the varargs methods, otherwise known as the ellipsis.
    -  3.8.5 Pointer Parameters
      -  DO provide an alternative for any member that takes a pointer argument, because pointers are not CLS-compliant.
      -  DO follow common pointer-related conventions when designing members with pointers
      -  AVOID doing expensive argument checking of pointer arguments.

## 4. Designing for Extensibility

-  4.1 Unsealed Classes
  -  CONSIDER using unsealed classes with no added virtual or protected members as a great way to provide inexpensive yet much appreciated extensibility to a framework.
-  4.2 Protected Members
  -  CONSIDER using protected members for advanced customization
  -  DO treat protected members in unsealed classes as public for the purpose of security, documentation, and compatibility analysis.
-  4.3 Events and Callbacks
  -  Do
    -  DO prefer events over plain callbacks, because they are more familiar to a broader range of developers and are integrated with Visual Studio statement completion.
    -  DO use the new Func<...>, Action<...>, or Expression<...> types instead of custom delegates, when defining APIs with callbacks.
    -  DO measure and understand performance implications of using Expression<...>, instead of using Func<...> and Action<...> delegates.
    -  DO understand that by calling a delegate, you are executing arbitrary code and that could have security, correctness, and compatibility repercussions.
  -  Consider
    -  CONSIDER using callbacks to allow users to provide custom code to be executed by the framework.
    -  CONSIDER using events to allow users to customize the behavior of a framework without the need for understanding object-oriented design
  -  Avoid
    -  AVOID using callbacks in performance-sensitive APIs.
-  4.4 Virtual Members
  - DO prefer protected accessibility over public accessibility for virtual members. Public members should provide extensibility (if required) by calling into a protected virtual member
  - CONSIDER limiting extensibility to only what is absolutely necessary.
  - DO NOT make members virtual unless you have a good reason to do so and you are aware of all the costs related to designing, testing, and maintaining virtual members.
-  4.5 Abstractions (Abstract Types and Interfaces)
  - DO choose carefully between an abstract class and an interface when designing an abstraction.
  - CONSIDER providing reference tests for concrete implementations of abstractions
  - DO NOT provide abstractions unless they are tested by developing several concrete implementations and APIs consuming the abstractions
-  4.6 Base Classes for Implementing Abstractions
  - CONSIDER making base classes abstract even if they don’t contain any abstract members. This clearly communicates to the users that the class is designed solely to be inherited from
  - CONSIDER placing base classes in a separate namespace from the mainline scenario types.
  - AVOID naming base classes with a "Base" suffix if the class is intended for use in public APIs
-  4.7 Sealing
  - CONSIDER sealing members that you override
  - DO NOT seal classes without having a good reason to do so
  - DO NOT declare protected or virtual members on sealed types

## 5. Exception Design

-  5.1 Exception Throwing
  -  Do
    -  DO report execution failures by throwing exceptions
    -  DO document all exceptions thrown by publicly callable members because of a violation of the member contract (rather than a system failure) and treat them as part of your contract
  -  Consider
    -  CONSIDER terminating the process by calling System.Environment.FailFast
    -  CONSIDER the performance implications of throwing exceptions
    -  CONSIDER using exception builder methods
  -  Avoid
    -  AVOID explicitly throwing exceptions from finally blocks. Implicitly thrown exceptions resulting from calling methods that throw are acceptable
  -  Do Not
    -  DO NOT return error codes
    -  DO NOT use exceptions for the normal flow of control, if possible
    -  DO NOT have public members that can either throw or not based on some option
    -  DO NOT have public members that return exceptions as the return value or an out parameter
    -  DO NOT throw exceptions from exception filter blocks
-  5.2 Using Standard Exception Types
  -  5.2.1 Exception and SystemException
    -  AVOID catching System.Exception or System.SystemException, except in top-level exception handlers
    -  DO NOT throw System.Exception or System.SystemException.
    -  DO NOT catch  System.Exception or  System.SystemException in framework code, unless you intend to rethrow
  -  5.2.2 ApplicationException
    -  DO NOT throw or derive from ApplicationException.
  -  5.2.3 InvalidOperationException
    -  DO throw an InvalidOperationException if the object is in an inappropriate state
  -  5.2.4 ArgumentException, ArgumentNullException, and ArgumentOutOfRangeException
    -  DO throw ArgumentException or one of its subtypes if bad arguments are passed to a member. Prefer the most derived exception type, if applicable
    -  DO set the ParamName property when throwing one of the subclasses of ArgumentException
    -  DO use value for the name of the implicit value parameter of property setters
  -  5.2.5 NullReferenceException, IndexOutOfRangeException, and AccessViolationException
    -  DO NOT allow publicly callable APIs to explicitly or implicitly throw NullReferenceException, AccessViolationException, or IndexOutOfRangeException
  -  5.2.6 StackOverflowException
    -  DO NOT explicitly throw StackOverflowException. The exception should be explicitly thrown only by the CLR
    -  DO NOT catch StackOverflowException
  -  5.2.7 OutOfMemoryException
    -  DO NOT explicitly throw OutOfMemoryException. This exception is to be thrown only by the CLR infrastructure
  -  5.2.8 ComException, SEHException, and ExecutionEngineException
    -  DO NOT explicitly throw COMException, ExecutionEngineException, and SEHException. These exceptions are to be thrown only by the CLR infrastructure.
-  5.3 Exceptions and Performance
  -  DO NOT use error codes because of concerns that exceptions might affect performance negatively
  -  CONSIDER the Tester-Doer Pattern for members that might throw exceptions in common scenarios to avoid performance problems related to exceptions
  -  CONSIDER the Try-Parse Pattern for members that might throw exceptions in common scenarios to avoid performance problems related to exceptions
  -  DO use the prefix "Try" and Boolean return type for methods implementing this pattern
  -  DO provide an exception-throwing member for each member using the Try-Parse Pattern

## 6. Usage Guidelines

-  6.1 Arrays
  -  DO prefer using collections over arrays in public APIs. The Collections section provides details about how to choose between collections and arrays
  -  CONSIDER using jagged arrays instead of multidimensional arrays
  -  DO NOT use read-only array fields
-  6.2 Attributes
  -  DO name custom attribute classes with the suffix "Attribute."
  -  DO apply the AttributeUsageAttribute to custom attributes
  -  DO provide settable properties for optional arguments
  -  DO provide get-only properties for required arguments
  -  DO provide constructor parameters to initialize properties corresponding to required arguments
  -  DO seal custom attribute classes, if possible. This makes the look-up for the attribute faster
  -  AVOID providing constructor parameters to initialize properties corresponding to the optional arguments
  -  AVOID overloading custom attribute constructors
-  6.3 Guidelines for Collections
  -  DO NOT use weakly typed collections in public APIs.
  -  DO NOT use ArrayList or List<T> in public APIs
  -  DO NOT use Hashtable or Dictionary<TKey,TValue> in public APIs
  -  DO NOT use IEnumerator<T>, IEnumerator, or any other type that implements either of these interfaces, except as the return type of a GetEnumerator method
  -  DO NOT implement both IEnumerator<T> and IEnumerable<T> on the same type
  -  6.3.1 Collection Parameters
    -  DO use the least-specialized type possible as a parameter type. Most members taking collections as parameters use the IEnumerable<T> interface
    -  AVOID using ICollection<T> or ICollection as a parameter just to access the Count property;  Instead, consider using IEnumerable<T> or IEnumerable
  -  6.3.2 Collection Properties and Return Values
    -  DO use Collection<T> or a subclass of Collection<T> for properties or return values representing read/write collections
    -  DO use ReadOnlyCollection<T>, a subclass of ReadOnlyCollection<T>, or in rare cases IEnumerable<T> for properties or return values representing read-only collections
    -  CONSIDER using subclasses of generic base collections instead of using the collections directly
    -  CONSIDER returning a subclass of Collection<T> or ReadOnlyCollection<T> from very commonly used methods and properties
    -  CONSIDER using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.)
    -  DO NOT provide settable collection properties
    -  DO NOT return null values from collection properties or from methods returning collections. Return an empty collection or an empty array instead
  -  6.3.3 Snapshots Versus Live Collections
    -  DO use either a snapshot collection or a live IEnumerable<T> (or its subtype) to represent collections that are volatile
    -  DO NOT return snapshot collections from properties. Properties should return live collections
  -  6.3.4 Choosing Between Arrays and Collections
    -  DO prefer collections over arrays
    -  DO use byte arrays instead of collections of bytes
    -  CONSIDER using arrays in low-level APIs to minimize memory consumption and maximize performance
    -  DO NOT use arrays for properties if the property would have to return a new array
  -  6.3.5 Implementing Custom Collections
    -  DO implement IEnumerable<T> when designing new collections. Consider implementing ICollection<T> or even IList<T> where it makes sense
    -  CONSIDER inheriting from Collection<T>, ReadOnlyCollection<T>, or KeyedCollection<TKey,TItem> when designing new collections
    -  CONSIDER implementing nongeneric collection interfaces (IList and ICollection) if the collection will often be passed to APIs taking these interfaces as input
    -  AVOID implementing collection interfaces on types with complex APIs unrelated to the concept of a collection
    -  DO NOT inherit from nongeneric base collections such as CollectionBase. Use Collection<T>, ReadOnlyCollection<T>, and KeyedCollection<TKey,TItem>  instead
  -  6.3.6 Naming Custom Collections
    -  DO use the "Dictionary" suffix in names of abstractions implementing IDictionary or IDictionary<TKey,TValue>
    -  DO use the "Collection" suffix in names of types implementing IEnumerable (or any of its descendants) and representing a list of items
    -  DO use the appropriate data structure name for custom data structures
    -  CONSIDER prefixing collection names with the name of the item type - AddressCollection, DisposableCollection
    -  CONSIDER using the "ReadOnly" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework
    -  AVOID using any suffixes implying particular implementation, such as "LinkedList" or "Hashtable," in names of collection abstractions
-  6.4 Serialization
  -  Data Contract Serialization,           XML Serialization,                    Runtime Serialization (Binary and SOAP)
    -  DO think about serialization when you design new types
    -  6.4.1 Choosing the Right Serialization Technology to Support
      -  CONSIDER supporting Data Contract Serialization if instances of your type might need to be persisted or used in Web Services
      -  CONSIDER supporting the XML Serialization instead of or in addition to Data Contract Serialization if you need more control over the XML format that is produced when the type is serialized
      -  CONSIDER supporting the Runtime Serialization if instances of your type need to travel across .NET Remoting boundaries
      -  AVOID supporting Runtime Serialization or XML Serialization just for general persistence reasons. Prefer Data Contract Serialization instead
    -  6.4.2 Supporting Data Contract Serialization
      -  DO implement a getter and setter on all properties that have DataMemberAttribute
      -  DO consider backward and forward compatibility when creating or changing serializable types
      -  CONSIDER marking data members of your type public if the type can be used in partial trust
      -  CONSIDER using the serialization callbacks for initialization of deserialized instances
      -  CONSIDER using the KnownTypeAttribute to indicate concrete types that should be used when deserializing a complex object graph
      -  CONSIDER implementing IExtensibleDataObject to allow round-tripping between different versions of the type
    -  6.4.3 Supporting XML Serialization
      -  AVOID designing your types specifically for XML Serialization, unless you have a very strong reason to control the shape of the XML produced. This serialization technology has been superseded by the Data Contract Serialization discussed in the previous section.
      -  CONSIDER implementing the IXmlSerializable interface if you want even more control over the shape of the serialized XML than what’s offered by applying the XML Serialization attributes. Two methods of the interface, ReadXml and WriteXml, allow you to fully control the serialized XML stream. You can also control the XML schema that gets generated for the type by applying the XmlSchemaProviderAttribute
    -  6.4.4 Supporting Runtime Serialization
      -  DO make the serialization constructor protected and provide two parameters typed and named exactly as shown in the sample here

      [Serializable]
      public class Person : ISerializable
      { 

      protected Person(SerializationInfo info, StreamingContext context)
	{ // ... } 

      }

      DO implement the ISerializable members explicitly

      DO apply a link demand to ISerializable.GetObjectData implementation. This ensures that only fully trusted core and the Runtime Serializer have access to the member

      CONSIDER supporting Runtime Serialization if your types will be used with .NET Remoting.

      CONSIDER implementing the Runtime Serializable Pattern if you want complete control over the serialization process
    -  6.4.5 System.Xml Usage
      -  DO use XmlReader, IXPathNavigable, or subtypes of XNode as input or output of members that accept or return XML
      -  DO NOT use XmlNode or XmlDocument to represent XML data
      -  DO NOT subclass XmlDocument if you want to create a type representing an XML view of an underlying object model or data source
    -  6.4.6 Equality Operators
      -  DO ensure that Object.Equals and the equality operators have exactly the same semantics and similar performance characteristics
      -  AVOID throwing exceptions from equality operators. Instead, return false.
      -  DO NOT overload one of the equality operators and not the other
      -  6.4.6.1 Equality Operators on Value Types
        -  DO overload the equality operators on value types, if equality is meaningful
      -  6.4.6.2 Equality Operators on Reference Types
        -  AVOID overloading equality operators on mutable reference types
        -  AVOID overloading equality operators on reference types if the implementation would be significantly slower than that of reference equality

## 7. Common Design Patterns

-  7.1 Dependency Properties
  -  DO provide the dependency properties, if you need the properties to support WPF features such as styling, triggers, data binding, animations, dynamic resources, and inheritance
  -  7.1.1 Dependency Property Design
    -  Do
      -  DO inherit from DependencyObject, or one of its subtypes, when implementing dependency properties
      -  DO provide a regular CLR property and public static read-only field storing an instance of System.Windows.DependencyProperty for each dependency property
      -  DO implement dependency properties by calling instance methods DependencyObject.GetValue and DependencyObject.SetValue
      -  DO name the dependency property static field by suffixing the name of the property with "Property
    -  Do Not
      -  DO NOT set default values of dependency properties explicitly in code; set them in metadata instead
      -  DO NOT put code in the property accessors other than the standard code to access the static field
      -  DO NOT use dependency properties to store secure data
  -  7.1.2 Attached Dependency Property Design
    -  e.g. <Button Grid.Column="0">Click</Button>
    -  e.g. <Button Grid.Column="1">Click</Button>
  -  7.1.3 Dependency Property Validation
    -  DO NOT put dependency property validation logic in the property’s accessors. Instead, pass a validation callback to  DependencyProperty.Register method
  -  7.1.4 Dependency Property Change Notifications
    -  DO NOT implement change notification logic in dependency property accessors. Dependency properties have a built-in change notifications feature that must be used by supplying a change notification callback to the PropertyMetadata
  -  7.1.5 Dependency Property Value Coercion
    -  DO NOT implement coercion logic in dependency property accessors
-  7.2 Dispose Pattern
  -  DO implement the Basic Dispose Pattern on types containing instances of disposable types
  -  DO implement the Basic Dispose Pattern and provide a finalizer on types holding resources that need to be freed explicitly and that do not have finalizers
  -  CONSIDER implementing the Basic Dispose Pattern on classes that themselves don’t hold unmanaged resources or disposable objects but are likely to have subtypes that do. e.g., System.IO.Stream
  -  7.2.1 Basic Dispose Pattern
    - DO declare a protected virtual void Dispose(bool disposing) method to centralize all logic related to releasing unmanaged resources
    - DO implement the IDisposable interface by simply calling Dispose(true) followed by GC.SuppressFinalize(this)
    - DO allow the Dispose(bool) method to be called more than once. The method might choose to do nothing after the first call
    - DO throw an ObjectDisposedException from any member that cannot be used after the object has been disposed of.
    - CONSIDER providing method Close(), in addition to the Dispose(), if close is standard terminology in the area
    - AVOID throwing an exception from within Dispose(bool) except under critical situations where the containing process has been corrupted (leaks, inconsistent shared state, etc.)
    - DO NOT make the parameterless Dispose method virtual
    - DO NOT declare any overloads of the Dispose method other than Dispose() and Dispose(bool)
  -  7.2.2 Finalizable Types
    - DO make a type finalizable if the type is responsible for releasing an unmanaged resource that does not have its own finalizer
    - DO implement the Basic Dispose Pattern on every finalizable type
    - DO make your Finalize method protected
    - CONSIDER creating and using a critical finalizable object (a type with a type hierarchy that contains CriticalFinalizerObject) for situations in which a finalizer absolutely must execute even in the face of forced application domain unloads and thread aborts
    - AVOID making types finalizable
    - DO NOT make value types finalizable
    - DO NOT access any finalizable objects in the finalizer code path, because there is significant risk that they will have already been finalized
    - DO NOT let exceptions escape from the finalizer logic, except for system-critical failures
